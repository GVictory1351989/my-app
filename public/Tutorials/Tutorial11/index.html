<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>JS Callback, Promise, Async/Await Tutorial</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 30px;
            background-color: #f4f6f8;
        }

        h1, h2 {
            color: #005f99;
        }

        .section {
            margin-bottom: 40px;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            background-color: #fff;
        }

        button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .output {
            margin-top: 10px;
            background: #f1f1f1;
            padding: 10px;
            border-left: 4px solid #007acc;
            white-space: pre-line;
        }
    </style>
</head>
<body>

    <h1>📘 JavaScript Callback, Promise, Fetch, Async/Await</h1>
    <h2>Promise</h2>
    <p>
        A Promise is a way to handle asynchronous operations in JavaScript. It allows handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.
        A Promise is in one of these states:
        <ul>
       <li> pending: initial state, neither fulfilled nor rejected.</li>
       <li> fulfilled: meaning that the operation completed successfully.</li>
       <li> rejected: meaning that the operation failed.</li>
       </ul>
        <h2>Callbacks</h2>
    <p>call back Let us see a callback function which can take two parameters. The first parameter is err and the second is result. If the err parameter is false, there will not be error other wise it will return an error.</p>
    <pre>
        <code>
            //In this case the err has a value and it will return the err block.
            //Callback
            const doSomething = callback => {
            setTimeout(() => {
            const skills = ['HTML', 'CSS', 'JS']
            callback('It did not go well', skills)
            }, 2000)
            }

            const callback = (err, result) => {
            if (err) {
            return console.log(err)
            }
            return console.log(result)
            }

            doSomething(callback)

            // after 2 seconds it will print
            It did not go well


            //In this case the err is false and it will return the else block which is the result.

            const doSomething = callback => {
            setTimeout(() => {
            const skills = ['HTML', 'CSS', 'JS']
            callback(false, skills)
            }, 2000)
            }

            doSomething((err, result) => {
            if (err) {
            return console.log(err)
            }
            return console.log(result)
            })

            // after 2 seconds it will print the skills
            ["HTML", "CSS", "JS"]
        </code>  
   </pre>
    <h2>Promise constructor</h2>
    <p>We can create a promise using the Promise constructor. We can create a new promise using the key word new followed by the word Promise and followed by a parenthesis. Inside the parenthesis, it takes a callback function. The promise callback function has two parameters which are the resolve and reject functions.</p>
    <pre>
        <code>
            // syntax
            const promise = new Promise((resolve, reject) => {
            resolve('success')
            reject('failure')
            })

            // Promise
            const doPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
            const skills = ['HTML', 'CSS', 'JS']
            if (skills.length > 0) {
            resolve(skills)
            } else {
            reject('Something wrong has happened')
            }
            }, 2000)
            })

            doPromise
            .then(result => {
            console.log(result)
            })
            .catch(error => console.log(error))

            //["HTML", "CSS", "JS"]

            // Promise
            const doPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
            const skills = ['HTML', 'CSS', 'JS']
            if (skills.includes('Node')) {
            resolve('fullstack developer')
            } else {
            reject('Something wrong has happened')
            }
            }, 2000)
            })

            doPromise
            .then(result => {
            console.log(result)
            })
            .catch(error => console.error(error))

            //Something wrong has happened

        </code>
    </pre>

    <h2>Fetch API</h2>
    <p>The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. In this challenge we will use fetch to request url and APIS. In addition to that let us see demonstrate use case of promises in accessing network resources using the fetch API.</p>
    <pre><code>
    const url = 'https://restcountries.com/v2/all' // countries api
    fetch(url)
    .then(response => response.json()) // accessing the API data as JSON
    .then(data => {
    // getting the data
    console.log(data)
    })
    .catch(error => console.error(error)) // handling error if something wrong happens
</code></pre>
    <h2>Async and Await</h2>
    <p>Async and await is an elegant way to handle promises. </p>
    <pre>
        <code>
            const square = async function (n) { // async added 
            return n * n
            }

            square(2)

            //Promise {<resolved>
    : 4}


    const square = async function (n) {
    return n * n
    }
    const value = await square(2)
    console.log(value)

    Let us fetch API data using both promise method and async and await method.

    .promise

    const url = 'https://restcountries.com/v2/all'
    fetch(url)
    .then(response => response.json())
    .then(data => {
    console.log(data)
    })
    .catch(error => console.error(error))

    .async and await

    const fetchData = async () => {
    try {
    const response = await fetch(url)
    const countries = await response.json()
    console.log(countries)
    } catch (err) {
    console.error(err)
    }
    }
    console.log('===== async and await')
    fetchData()
</code>
    </pre>

    <h2>Event Listeners</h2>
    <pre>
        <code>

            selectedElement.addEventListener('eventlistner', function(e) {
            // the activity you want to occur after the event will be in here
            })
            // or

            selectedElement.addEventListener('eventlistner', e => {
            // the activity you want to occur after the event will be in here
            })

            // script tag ke andar rahega
            const button = document.querySelector('button')
            button.addEventListener('click', e => {
            console.log('e gives the event listener object:', e)
            console.log('e.target gives the selected element: ', e.target)
            console.log(
            'e.target.textContent gives content of selected element: ',
            e.target.textContent
            )
            })


            button onclick="clickMe()">Click Me
            // script tag ke andar>script>
            const clickMe = () => {
            alert('We can attach event on HTML element')
            }
            //>/script>
            click - when the element clicked
            dblclick - when the element double clicked
            mouseenter - when the mouse point enter to the element
            mouseleave - when the mouse pointer leave the element
            mousemove - when the mouse pointer move on the element
            mouseover - when the mouse pointer move on the element
            mouseout -when the mouse pointer out from the element
            input -when value enter to input field
            change -when value change on input field
            blur -when the element is not focused
            keydown - when a key is down
            keyup - when a key is up
            keypress - when we press any key
            onload - when the browser has finished loading a page
        </code>
</pre>
    <h2>Closure</h2>
    <p>JavaScript allows writing function inside an outer function. We can write as many inner functions as we want. If inner function access the variables of outer function then it is called closure.</p>
    <pre>
      <code>
    function outerFunction() {
    let count = 0;
    function plusOne() {
    count++
    return count
    }
    function minusOne() {
    count--
    return count
    }

    return {
    plusOne:plusOne(),
    minusOne:minusOne()
    }
    }
    const innerFuncs = outerFunction()

    console.log(innerFuncs.plusOne)
    console.log(innerFuncs.minusOne)
    </code>
</pre>
    <h2>
        Coding standards
    </h2>
    <pre><code>
    Coding conventions helps:

    to write clean code
    to improve code readability
    to improve code re-useability and maintainability
    Coding conventions includes

    Naming and declaration rules for variables
    Naming and declaration rules for functions
    Rules for the use of white space, indentation, and comments
    Programming practices and principles
    Conventions use in 30DaysOfJavaScript
    In this challenge we follow the regular JavaScript convention but I added also my preference of writing.

    We used camelCase for variables and functions.
    All variable names start with a letter.
    We chose to use const for constants, arrays, objects and functions. In stead of double quote, we chose to use single quote or backtick. Single quote is becoming trendy.
    We also removed semicolons from our code but it is a matter of personal preference.
    Space around arithmetic operators, assignment operators and after comma
    Arrow function instead of function declaration
    Explicit return instead of implicit return if the function is one liner
    No trailing comma in the last value of an object
    We prefer this +=, -=, *= /=, **= instead of the longer version
    When we use console.log() it is good to print with a tag string to identify from where the console is coming
</code></pre>
    <h2>Document Object Model (DOM)</h2>
    <pre><code>
    getElementsByTagName():takes a tag name as a string parameter and this method returns an HTMLCollection object.
    document.getElementsByTagName('tagname')

    const allTitles = document.getElementsByTagName('h1')

    console.log(allTitles) //HTMLCollections
    console.log(allTitles.length) // 4

    for (let i = 0; i < allTitles.length; i++) {
    console.log(allTitles[i]) // prints each elements in the HTMLCollection
    }
    . getElementsByClassName() method returns an HTMLCollection object.
    . getElementsById() targets a single HTML element. We pass the id without # as an argument.
    . The document.querySelector method can select an HTML or HTML elements by tag name, by id or by class name.

    let firstTitle = document.querySelector('h1') // select the first available h1 element
    let firstTitle = document.querySelector('#first-title') // select id with first-title
    let firstTitle = document.querySelector('.title') // select the first available element with class title

    querySelectorAll: can be used to select html elements by its tag name or class. It returns a nodeList
    which is an array like object which supports array methods.

    const allTitles = document.querySelectorAll('h1') # selects all the available h1 elements in the page

    console.log(allTitles.length) // 4
    for (let i = 0; i < allTitles.length; i++) {
    console.log(allTitles[i])
    }

    allTitles.forEach(title => console.log(title))
    const allTitles = document.querySelectorAll('.title') // the same goes for selecting using class

    Adding attribute
    An attribute is added in the opening tag of HTML which gives
    additional information about the element.

    const titles = document.querySelectorAll('h1')
    titles[3].className = 'title'
    titles[3].id = 'fourth-title'

    The setAttribute() method set any html attribute.

    const titles = document.querySelectorAll('h1')
    titles[3].setAttribute('class', 'title')
    titles[3].setAttribute('id', 'fourth-title')

    Adding class using classList
    The class list method is a good method to append additional class.

    Removing class using remove
    titles[3].classList.remove('title', 'header-title')

    . Adding Text content using textContent

    const titles = document.querySelectorAll('h1')
    titles[3].textContent = 'Fourth Title'

    Adding Text Content using innerHTML
    Most people get confused between textContent and innerHTML.
    textContent is meant to add text to an HTML element,
    however innerHTML can add a text or HTML element or elements as a child.

    const titles = document.querySelectorAll('h1')
    titles[3].textContent = 'Fourth Title'

    Adding Style Color

    const titles = document.querySelectorAll('h1')
    titles.forEach((title, i) => {
    title.style.fontSize = '24px' // all titles will have 24px font size
    if (i % 2 === 0) {
    title.style.color = 'green'
    } else {
    title.style.color = 'red'
    }
    })

    Adding Style Background Color

    const titles = document.querySelectorAll('h1')
    titles.forEach((title, i) => {
    title.style.fontSize = '24px' // all titles will have 24px font size
    if (i % 2 === 0) {
    title.style.backgroundColor = 'green'
    } else {
    title.style.backgroundColor = 'red'
    }
    })

    Adding Style Font Size

    const titles = document.querySelectorAll('h1')
    titles.forEach((title, i) => {
    title.style.fontSize = '24px' // all titles will have 24px font size
    if (i % 2 === 0) {
    title.style.fontSize = '20px'
    } else {
    title.style.fontSize = '30px'
    }
    })

</code></pre>
            <!-- 🔹 Callback Section -->
            <div class="section">
                <h2>🔁 1. Callback Function</h2>
                <p><strong>Kya hai?</strong> Callback ek function hota hai jo doosre function ko parameter ke roop mein diya jata hai, taaki jab kaam complete ho tab call ho.</p>
                <p><strong>Use:</strong> Asynchronous kaam jaise data laana, delay lagana, file read karna.</p>
                <button onclick="runCallback(true)">Run Callback (Error)</button>
                <button onclick="runCallback(false)">Run Callback (Success)</button>
                <div id="callback-output" class="output"></div>
            </div>

            <!-- 🔹 Promise Section -->
            <div class="section">
                <h2>📦 2. Promise</h2>
                <p><strong>Kya hai?</strong> Promise ek object hai jo future mein success ya error ka result deta hai.</p>
                <p><strong>Use:</strong> Asynchronous kaam ko chainable aur readable banana.</p>
                <button onclick="runPromise(true)">Run Promise (Success)</button>
                <button onclick="runPromise(false)">Run Promise (Failure)</button>
                <div id="promise-output" class="output"></div>
            </div>

            <!-- 🔹 Fetch with .then -->
            <div class="section">
                <h2>🌐 3. Fetch API using .then()</h2>
                <p><strong>Kya hai?</strong> `fetch()` network se data laane ka tareeka hai. Yeh ek promise return karta hai.</p>
                <p><strong>Use:</strong> Web API se data fetch karna jaise REST API.</p>
                <button onclick="fetchWithThen()">Fetch Countries (.then)</button>
                <div id="fetch-then-output" class="output"></div>
            </div>

            <!-- 🔹 Async/Await -->
            <div class="section">
                <h2>⚡ 4. Async / Await</h2>
                <p><strong>Kya hai?</strong> `async/await` Promise ko handle karne ka modern aur easy syntax hai.</p>
                <p><strong>Use:</strong> Readable async code likhne ke liye, `try/catch` ke saath error handle karna.</p>
                <button onclick="fetchWithAsync()">Fetch Countries (async/await)</button>
                <div id="fetch-async-output" class="output"></div>
            </div>

            <!-- JavaScript Code Starts -->
            <script>
                // 📍 1. Callback Example
                function runCallback(isError) {
                    const output = document.getElementById("callback-output");

                    const doSomething = (callback) => {
                        setTimeout(() => {
                            const skills = ['HTML', 'CSS', 'JS'];
                            if (isError) {
                                callback("❌ Error: Something went wrong", skills);
                            } else {
                                callback(false, skills);
                            }
                        }, 1500);
                    };

                    doSomething((err, result) => {
                        if (err) {
                            output.textContent = err;
                        } else {
                            output.textContent = "✅ Skills: " + result.join(", ");
                        }
                    });
                }

                // 📍 2. Promise Example
                function runPromise(isSuccess) {
                    const output = document.getElementById("promise-output");

                    const doPromise = new Promise((resolve, reject) => {
                        setTimeout(() => {
                            const skills = ['HTML', 'CSS', 'JS'];
                            if (isSuccess) {
                                resolve(skills);
                            } else {
                                reject("❌ Error: Operation failed");
                            }
                        }, 1500);
                    });

                    doPromise
                        .then(result => {
                            output.textContent = "✅ Skills: " + result.join(", ");
                        })
                        .catch(error => {
                            output.textContent = error;
                        });
                }

                // 📍 3. Fetch using .then
                function fetchWithThen() {
                    const output = document.getElementById("fetch-then-output");
                    const url = 'https://restcountries.com/v2/all';

                    fetch(url)
                        .then(res => res.json())
                        .then(data => {
                            output.textContent = `🌍 Total Countries: ${data.length}\nExample: ${data[0].name}`;
                        })
                        .catch(err => {
                            output.textContent = "❌ Error: " + err;
                        });
                }

                // 📍 4. Fetch using async/await
                async function fetchWithAsync() {
                    const output = document.getElementById("fetch-async-output");
                    const url = 'https://restcountries.com/v2/all';

                    try {
                        const response = await fetch(url);
                        const data = await response.json();
                        output.textContent = `🌏 Total Countries: ${data.length}\nExample: ${data[1].name}`;
                    } catch (error) {
                        output.textContent = "❌ Error: " + error;
                    }
                }
            </script>

</body>
</html>
